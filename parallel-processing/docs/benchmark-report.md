# ThreadPool 병렬 파일 저장 벤치마크 리포트

> 테스트 일시: 2026-02-27
> 환경: Windows 11 Pro / Java 21.0.9 / Spring Boot 3.4.3
> 작업: 10,000개 JSON 파일 저장 (100폴더 x 100파일, 파일당 ~200줄)

---

## 1. 순차 처리 vs 병렬 처리 (50 스레드) 비교

### 원시 데이터

| Round | 전략 | 소요 시간 (ms) | 처리량 (files/sec) | 피크 메모리 (MB) |
|-------|------|---------------|-------------------|-----------------|
| 1     | Sequential     | 7,311  | 1,367.8  | 144.2 |
| 1     | ThreadPool(50) | 3,042  | 3,287.3  | 148.2 |
| 2     | Sequential     | 7,300  | 1,369.9  | 132.4 |
| 2     | ThreadPool(50) | 1,695  | 5,899.7  | 141.1 |
| 3     | Sequential     | 8,670  | 1,153.4  | 153.9 |
| 3     | ThreadPool(50) | 2,318  | 4,314.1  | 13.9  |

### 평균 비교

| 전략 | 평균 소요 시간 (ms) | 평균 처리량 (files/sec) | 배수 |
|------|--------------------|-----------------------|------|
| **Sequential**     | **7,760** | **1,297** | 1.0x |
| **ThreadPool(50)** | **2,352** | **4,500** | **3.5x** |

### 분석

```
Sequential:     ████████████████████████████████████████ 7,760ms
ThreadPool(50): ████████████                             2,352ms
                                                    3.3배 빠름
```

- 50개 스레드 병렬 처리가 순차 처리 대비 **평균 3.3배 빠름**
- 순차 처리는 7.3~8.7초로 편차가 크고, 병렬은 1.7~3.0초로 안정적
- 메모리 사용량은 두 전략 간 유의미한 차이 없음 (GC 타이밍 의존)
- 병렬 처리의 이점: 디스크 I/O 대기 시간 동안 다른 스레드가 JSON 직렬화 수행

---

## 2. 스레드 수별 병렬 처리 비교

### 원시 데이터

#### Round 1
| 스레드 수 | 소요 시간 (ms) | 처리량 (files/sec) | 피크 메모리 (MB) |
|-----------|---------------|-------------------|-----------------|
| 10        | 1,712         | 5,841.1           | 143.6           |
| 50        | 1,692         | 5,910.2           | 144.8           |
| 100       | 3,000         | 3,333.3           | 137.8           |
| 200       | 2,343         | 4,268.0           | 131.4           |

#### Round 2
| 스레드 수 | 소요 시간 (ms) | 처리량 (files/sec) | 피크 메모리 (MB) |
|-----------|---------------|-------------------|-----------------|
| 10        | 3,703         | 2,700.5           | 36.2            |
| 50        | 2,130         | 4,694.8           | 66.4            |
| 100       | 1,970         | 5,076.1           | 90.1            |
| 200       | 2,860         | 3,496.5           | 110.9           |

#### Round 3
| 스레드 수 | 소요 시간 (ms) | 처리량 (files/sec) | 피크 메모리 (MB) |
|-----------|---------------|-------------------|-----------------|
| 10        | 3,060         | 3,268.0           | 117.3           |
| 50        | 2,546         | 3,927.7           | 147.1           |
| 100       | 2,496         | 4,006.4           | 7.7             |
| 200       | 1,871         | 5,344.7           | 28.5            |

### 평균 결과

| 스레드 수 | 평균 소요 시간 (ms) | 평균 처리량 (files/sec) | 순차 대비 배수 | 실패 건수 |
|-----------|--------------------|-----------------------|--------------|----------|
| Sequential| 7,760              | 1,297                 | 1.0x         | 0        |
| **10**    | 2,825              | 3,937                 | 2.7x         | 0        |
| **50**    | 2,123              | 4,844                 | **3.7x**     | 0        |
| **100**   | 2,489              | 4,139                 | 3.1x         | 0        |
| **200**   | 2,358              | 4,370                 | 3.4x         | 0        |

---

## 3. 결론

### 순차 vs 병렬
- 병렬 처리는 어떤 스레드 수(10~200)에서든 순차 대비 **최소 2.7배 이상 빠름**
- 10,000개 파일 저장 기준으로 병렬 처리 도입은 확실한 성능 이점이 있음

### 최적 스레드 수

| 항목 | 권장 |
|------|------|
| 속도 우선 | **50개** (평균 2,123ms, 3.7배) |
| 균형 (속도 + 리소스) | **50~100개** |
| 리소스 절약 | **10개** (2.7배 개선에 최소 리소스) |

### 핵심 인사이트
1. **50개 스레드가 sweet spot** - 디스크 I/O 처리량과 CPU 병렬도의 균형점
2. **100~200개 스레드는 오히려 느려짐** - 컨텍스트 스위칭 + 디스크 경합 오버헤드
3. **10개 스레드만으로도 2.7배 개선** - 적은 리소스로 충분한 효과
4. **안정성은 모두 동일** - 전 구간에서 실패 0건

---

## 실행 방법

```bash
# 앱 실행
./gradlew bootRun

# 순차 처리 테스트
curl -X POST http://localhost:8080/api/poc/sequential

# 병렬 처리 테스트 (스레드 수 지정)
curl -X POST "http://localhost:8080/api/poc/thread-pool?threads=50"

# 결과 조회
curl http://localhost:8080/api/poc/results

# 파일 정리
curl -X DELETE http://localhost:8080/api/poc/cleanup
```
